* Compiling: Pong/
	* Compiling File: Pong//Ball.jack
	* Compiler output file: Pong//Ball.vm
	 * Beginning parsing
			 * Found Command: class Ball {
			 * Found Command: field int x, y;               
			 * Found Command: field int lengthx, lengthy;   
			 * Found Command: field int d, straightD, diagonalD;            
			 * Found Command: field boolean invert, positivex, positivey;   
			 * Found Command: 
			 * Found Command: field int leftWall, rightWall, topWall, bottomWall;  
			 * Found Command: 
			 * Found Command: field int wall;   
			 * Found Command: constructor Ball new(int Ax, int Ay,
			 * Found Command: int AleftWall, int ArightWall, int AtopWall, int AbottomWall) {    	
			 * Found Command: let x = Ax;		
			 * Found Command: let y = Ay;
			 * Found Command: let leftWall = AleftWall;
			 * Found Command: let rightWall = ArightWall - 6;    
			 * Found Command: let topWall = AtopWall; 
			 * Found Command: let bottomWall = AbottomWall - 6;  
			 * Found Command: let wall = 0;
			 * Found Command: do show();
			 * Found Command: return this;
			 * Found Command: }
			 * Found Command: method void dispose() {
			 * Found Command: do Memory.deAlloc(this);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void show() {
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void hide() {
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void draw() {
			 * Found Command: do Screen.drawRectangle(x, y, x + 5, y + 5);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method int getLeft() {
			 * Found Command: return x;
			 * Found Command: }
			 * Found Command: method int getRight() {
			 * Found Command: return x + 5;
			 * Found Command: }
			 * Found Command: method void setDestination(int destx, int desty) {
			 * Found Command: var int dx, dy, temp;
			 * Found Command: let lengthx = destx - x;    
			 * Found Command: let lengthy = desty - y;
			 * Found Command: let dx = Math.abs(lengthx);
			 * Found Command: let dy = Math.abs(lengthy);
			 * Found Command: let invert = (dx < dy);
			 * Found Command: if (invert) {
			 * Found Command: let temp = dx; 
			 * Found Command: let dx = dy;
			 * Found Command: let dy = temp;
			 * Found Command: let positivex = (y < desty);
			 * Found Command: let positivey = (x < destx);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: let positivex = (x < destx);
			 * Found Command: let positivey = (y < desty);
			 * Found Command: }
			 * Found Command: let d = (2 * dy) - dx;
			 * Found Command: let straightD = 2 * dy;
			 * Found Command: let diagonalD = 2 * (dy - dx);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method int move() {
			 * Found Command: do hide();
			 * Found Command: if (d < 0) { let d = d + straightD; }
			 * Found Command: else {
			 * Found Command: let d = d + diagonalD;
			 * Found Command: if (positivey) {
			 * Found Command: if (invert) { let x = x + 4; }
			 * Found Command: else { let y = y + 4; }
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (invert) { let x = x - 4; }
			 * Found Command: else { let y = y - 4; }
			 * Found Command: }
			 * Found Command: }
			 * Found Command: if (positivex) {
			 * Found Command: if (invert) { let y = y + 4; }
			 * Found Command: else { let x = x + 4; }
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (invert) { let y = y - 4; }
			 * Found Command: else { let x = x - 4; }
			 * Found Command: }
			 * Found Command: if (~(x > leftWall)) {
			 * Found Command: let wall = 1;    
			 * Found Command: let x = leftWall;
			 * Found Command: }
			 * Found Command: if (~(x < rightWall)) {
			 * Found Command: let wall = 2;    
			 * Found Command: let x = rightWall;
			 * Found Command: }
			 * Found Command: if (~(y > topWall)) {
			 * Found Command: let wall = 3;    
			 * Found Command: let y = topWall;
			 * Found Command: }
			 * Found Command: if (~(y < bottomWall)) {
			 * Found Command: let wall = 4;    
			 * Found Command: let y = bottomWall;
			 * Found Command: }
			 * Found Command: do show();
			 * Found Command: return wall;
			 * Found Command: }
			 * Found Command: method void bounce(int bouncingDirection) {
			 * Found Command: var int newx, newy, divLengthx, divLengthy, factor;
			 * Found Command: 
			 * Found Command: let divLengthx = lengthx / 10;
			 * Found Command: let divLengthy = lengthy / 10;
			 * Found Command: if (bouncingDirection = 0) { let factor = 10; }
			 * Found Command: else {
			 * Found Command: if (((~(lengthx < 0)) & (bouncingDirection = 1)) | ((lengthx < 0) & (bouncingDirection = (-1)))) {
			 * Found Command: let factor = 20; 
			 * Found Command: }
			 * Found Command: else { let factor = 5; } 
			 * Found Command: }
			 * Found Command: if (wall = 1) {
			 * Found Command: let newx = 506;
			 * Found Command: let newy = (divLengthy * (-50)) / divLengthx;
			 * Found Command: let newy = y + (newy * factor);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (wall = 2) {
			 * Found Command: let newx = 0;
			 * Found Command: let newy = (divLengthy * 50) / divLengthx;
			 * Found Command: let newy = y + (newy * factor);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (wall = 3) {
			 * Found Command: let newy = 250;
			 * Found Command: let newx = (divLengthx * (-25)) / divLengthy;
			 * Found Command: let newx = x + (newx * factor);
			 * Found Command: }
			 * Found Command: else { 
			 * Found Command: let newy = 0;
			 * Found Command: let newx = (divLengthx * 25) / divLengthy;
			 * Found Command: let newx = x + (newx * factor);
			 * Found Command: }
			 * Found Command: }
			 * Found Command: }
			 * Found Command: do setDestination(newx, newy);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: straightD	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: diagonalD	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: boolean	     TYPE: keyword
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: constructor	     TYPE: keyword
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: AleftWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: ArightWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: AtopWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: AbottomWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: AleftWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ArightWall	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 6	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: AtopWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: AbottomWall	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 6	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Memory	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: deAlloc	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: setDestination	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: temp	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Math	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: abs	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Math	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: abs	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: temp	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: temp	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: straightD	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: diagonalD	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: straightD	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: diagonalD	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: bounce	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: |	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 20	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 506	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 250	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 25	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: 25	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: setDestination	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Compiling
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: x
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: y
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: lengthx
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: lengthy
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: d
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: straightD
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: diagonalD
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: boolean	NAME: invert
				* Inserting symbol into class table: SEGMENT: 1	TYPE: boolean	NAME: positivex
				* Inserting symbol into class table: SEGMENT: 1	TYPE: boolean	NAME: positivey
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: leftWall
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: rightWall
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: topWall
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: bottomWall
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: wall
			* Done Compiling Class Var Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Ax
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Ay
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: AleftWall
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: ArightWall
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: AtopWall
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: AbottomWall
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: destx
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: desty
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Var Declaration
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: dx
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: dy
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: temp
			* Done Compiling Var Declaration
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: bouncingDirection
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Var Declaration
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: newx
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: newy
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: divLengthx
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: divLengthy
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: factor
			* Done Compiling Var Declaration
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
		* Done Compiling
* Freeing all data used
	* Compiling File: Pong//Bat.jack
	* Compiler output file: Pong//Bat.vm
	 * Beginning parsing
			 * Found Command: class Bat {
			 * Found Command: field int x, y;           
			 * Found Command: field int width, height;  
			 * Found Command: field int direction;      
			 * Found Command: constructor Bat new(int Ax, int Ay, int Awidth, int Aheight) {
			 * Found Command: let x = Ax;
			 * Found Command: let y = Ay;
			 * Found Command: let width = Awidth;
			 * Found Command: let height = Aheight;
			 * Found Command: let direction = 2;
			 * Found Command: do show();
			 * Found Command: return this;
			 * Found Command: }
			 * Found Command: method void dispose() {
			 * Found Command: do Memory.deAlloc(this);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void show() {
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void hide() {
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void draw() {
			 * Found Command: do Screen.drawRectangle(x, y, x + width, y + height);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void setDirection(int Adirection) {
			 * Found Command: let direction = Adirection;
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method int getLeft() {
			 * Found Command: return x;
			 * Found Command: }
			 * Found Command: method int getRight() {
			 * Found Command: return x + width;
			 * Found Command: }
			 * Found Command: method void setWidth(int Awidth) {
			 * Found Command: do hide();
			 * Found Command: let width = Awidth;
			 * Found Command: do show();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void move() {
			 * Found Command: if (direction = 1) {
			 * Found Command: let x = x - 4;
			 * Found Command: if (x < 0) { let x = 0; }
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do Screen.drawRectangle((x + width) + 1, y, (x + width) + 4, y + height);
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do Screen.drawRectangle(x, y, x + 3, y + height);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: let x = x + 4;
			 * Found Command: if ((x + width) > 511) { let x = 511 - width; }
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do Screen.drawRectangle(x - 4, y, x - 1, y + height);
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do Screen.drawRectangle((x + width) - 3, y, x + width, y + height);
			 * Found Command: }
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: constructor	     TYPE: keyword
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Aheight	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Aheight	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Memory	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: deAlloc	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: setDirection	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Adirection	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Adirection	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: setWidth	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Compiling
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: x
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: y
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: width
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: height
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: direction
			* Done Compiling Class Var Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Ax
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Ay
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Awidth
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Aheight
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Adirection
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
				* Inserting symbol into subroutine table: SEGMENT: 5	TYPE: int	NAME: Awidth
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
		* Done Compiling
* Freeing all data used
	* Compiling File: Pong//PongGame.jack
	* Compiler output file: Pong//PongGame.vm
	 * Beginning parsing
			 * Found Command: class PongGame {
			 * Found Command: static PongGame instance; 
			 * Found Command: field Bat bat;            
			 * Found Command: field Ball ball;          
			 * Found Command: field int wall;           
			 * Found Command: field boolean exit;       
			 * Found Command: field int score;          
			 * Found Command: field int lastWall;       
			 * Found Command: 
			 * Found Command: field int batWidth;
			 * Found Command: constructor PongGame new() {
			 * Found Command: do Screen.clearScreen();
			 * Found Command: let batWidth = 50;  
			 * Found Command: let bat = Bat.new(230, 229, batWidth, 7);
			 * Found Command: let ball = Ball.new(253, 222, 0, 511, 0, 229);
			 * Found Command: do ball.setDestination(400,0);
			 * Found Command: do Screen.drawRectangle(0, 238, 511, 240);
			 * Found Command: do Output.moveCursor(22,0);
			 * Found Command: do Output.printString("Score: 0");
			 * Found Command: 
			 * Found Command: let exit = false;
			 * Found Command: let score = 0;
			 * Found Command: let wall = 0;
			 * Found Command: let lastWall = 0;
			 * Found Command: return this;
			 * Found Command: }
			 * Found Command: method void dispose() {
			 * Found Command: do bat.dispose();
			 * Found Command: do ball.dispose();
			 * Found Command: do Memory.deAlloc(this);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: function void newInstance() {
			 * Found Command: let instance = PongGame.new();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: 
			 * Found Command: function PongGame getInstance() {
			 * Found Command: return instance;
			 * Found Command: }
			 * Found Command: method void run() {
			 * Found Command: var char key;
			 * Found Command: while (~exit) {
			 * Found Command: 
			 * Found Command: while ((key = 0) & (~exit)) {
			 * Found Command: let key = Keyboard.keyPressed();
			 * Found Command: do bat.move();
			 * Found Command: do moveBall();
			 * Found Command: do Sys.wait(50);
			 * Found Command: }
			 * Found Command: if (key = 130) { do bat.setDirection(1); }
			 * Found Command: else {
			 * Found Command: if (key = 132) { do bat.setDirection(2); }
			 * Found Command: else {
			 * Found Command: if (key = 140) { let exit = true; }
			 * Found Command: }
			 * Found Command: }
			 * Found Command: 
			 * Found Command: while ((~(key = 0)) & (~exit)) {
			 * Found Command: let key = Keyboard.keyPressed();
			 * Found Command: do bat.move();
			 * Found Command: do moveBall();
			 * Found Command: do Sys.wait(50);
			 * Found Command: }
			 * Found Command: }
			 * Found Command: if (exit) {
			 * Found Command: do Output.moveCursor(10,27);
			 * Found Command: do Output.printString("Game Over");
			 * Found Command: }
			 * Found Command: 
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void moveBall() {
			 * Found Command: var int bouncingDirection, batLeft, batRight, ballLeft, ballRight;
			 * Found Command: let wall = ball.move();
			 * Found Command: if ((wall > 0) & (~(wall = lastWall))) {
			 * Found Command: let lastWall = wall;
			 * Found Command: let bouncingDirection = 0;
			 * Found Command: let batLeft = bat.getLeft();
			 * Found Command: let batRight = bat.getRight();
			 * Found Command: let ballLeft = ball.getLeft();
			 * Found Command: let ballRight = ball.getRight();
			 * Found Command: 
			 * Found Command: if (wall = 4) {
			 * Found Command: let exit = (batLeft > ballRight) | (batRight < ballLeft);
			 * Found Command: if (~exit) {
			 * Found Command: if (ballRight < (batLeft + 10)) { let bouncingDirection = -1; }
			 * Found Command: else {
			 * Found Command: if (ballLeft > (batRight - 10)) { let bouncingDirection = 1; }
			 * Found Command: }
			 * Found Command: let batWidth = batWidth - 2;
			 * Found Command: do bat.setWidth(batWidth);      
			 * Found Command: let score = score + 1;
			 * Found Command: do Output.moveCursor(22,7);
			 * Found Command: do Output.printInt(score);
			 * Found Command: }
			 * Found Command: }
			 * Found Command: do ball.bounce(bouncingDirection);
			 * Found Command: }
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: static	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: instance	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: boolean	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: constructor	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: clearScreen	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 230	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 229	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 7	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 253	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 222	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 229	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setDestination	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 400	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 238	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 240	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: moveCursor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 22	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: printString	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: Score: 0	     TYPE: stringConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Memory	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: deAlloc	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: function	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: newInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: instance	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: function	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: getInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: instance	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: run	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: char	     TYPE: keyword
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: while	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: while	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Keyboard	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: keyPressed	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: moveBall	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Sys	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: wait	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 130	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setDirection	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 132	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setDirection	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 140	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: while	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Keyboard	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: keyPressed	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: moveBall	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Sys	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: wait	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: moveCursor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 27	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: printString	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: Game Over	     TYPE: stringConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: moveBall	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: |	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setWidth	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: moveCursor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 22	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 7	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: printInt	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: bounce	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Compiling
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 0	TYPE: PongGame	NAME: instance
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: Bat	NAME: bat
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: Ball	NAME: ball
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: wall
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: boolean	NAME: exit
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: score
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: lastWall
			* Done Compiling Class Var Declaration
			* Compiling Class Var Declaration
				* Inserting symbol into class table: SEGMENT: 1	TYPE: int	NAME: batWidth
			* Done Compiling Class Var Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Statements
			* Compiling Return Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Var Declaration
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: char	NAME: key
			* Done Compiling Var Declaration
			* Compiling Statements
			* Compiling While Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling While Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Done Compiling While Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling While Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Done Compiling While Statement
			* Done Compiling Statements
			* Done Compiling While Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Var Declaration
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: bouncingDirection
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: batLeft
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: batRight
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: ballLeft
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: int	NAME: ballRight
			* Done Compiling Var Declaration
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Compiling Statements
			* Compiling If Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Statements
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Compiling Expression
			* Compiling Terminal
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Done Compiling Statements
			* Done Compiling If Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
		* Done Compiling
* Freeing all data used
	* Compiling File: Pong//Main.jack
	* Compiler output file: Pong//Main.vm
	 * Beginning parsing
			 * Found Command: class Main {
			 * Found Command: function void main() {
			 * Found Command: var PongGame game;
			 * Found Command: do PongGame.newInstance();
			 * Found Command: let game = PongGame.getInstance();
			 * Found Command: do game.run();
			 * Found Command: do game.dispose();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: Main	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: function	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: main	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: newInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: run	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Compiling
			* Compiling Subroutine Declaration
			* Compiling Parameter List
			* Done Compiling Parameter List
			* Compiling Subroutine Body
			* Compiling Var Declaration
				* Inserting symbol into subroutine table: SEGMENT: 3	TYPE: PongGame	NAME: game
			* Done Compiling Var Declaration
			* Compiling Statements
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Let Statement
			* Compiling Expression
			* Compiling Terminal
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Terminal
			* Done Compiling Expression
			* Done Compiling Let Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Do Statement
			* Compiling Subroutine Call
			* Compiling Expression List
			* Done Compiling Expression List
			* Done Compiling Subroutine Call
			* Done Compiling Do Statement
			* Compiling Return Statement
			* Done Compiling Return Statement
			* Done Compiling Statements
			* Done Compiling Subroutine Body
			* Done Compiling Subroutine Declaration
		* Done Compiling
* Freeing all data used
* Compiling: Pong/
	* Compiling File: Pong//Ball.jack
	* Tokenizer output file: Pong//BallT.xml
	* Analyzer output file: Pong//Ball.xml
	 * Beginning parsing
			 * Found Command: class Ball {
			 * Found Command: field int x, y;               
			 * Found Command: field int lengthx, lengthy;   
			 * Found Command: field int d, straightD, diagonalD;            
			 * Found Command: field boolean invert, positivex, positivey;   
			 * Found Command: 
			 * Found Command: field int leftWall, rightWall, topWall, bottomWall;  
			 * Found Command: 
			 * Found Command: field int wall;   
			 * Found Command: constructor Ball new(int Ax, int Ay,
			 * Found Command: int AleftWall, int ArightWall, int AtopWall, int AbottomWall) {    	
			 * Found Command: let x = Ax;		
			 * Found Command: let y = Ay;
			 * Found Command: let leftWall = AleftWall;
			 * Found Command: let rightWall = ArightWall - 6;    
			 * Found Command: let topWall = AtopWall; 
			 * Found Command: let bottomWall = AbottomWall - 6;  
			 * Found Command: let wall = 0;
			 * Found Command: do show();
			 * Found Command: return this;
			 * Found Command: }
			 * Found Command: method void dispose() {
			 * Found Command: do Memory.deAlloc(this);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void show() {
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void hide() {
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void draw() {
			 * Found Command: do Screen.drawRectangle(x, y, x + 5, y + 5);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method int getLeft() {
			 * Found Command: return x;
			 * Found Command: }
			 * Found Command: method int getRight() {
			 * Found Command: return x + 5;
			 * Found Command: }
			 * Found Command: method void setDestination(int destx, int desty) {
			 * Found Command: var int dx, dy, temp;
			 * Found Command: let lengthx = destx - x;    
			 * Found Command: let lengthy = desty - y;
			 * Found Command: let dx = Math.abs(lengthx);
			 * Found Command: let dy = Math.abs(lengthy);
			 * Found Command: let invert = (dx < dy);
			 * Found Command: if (invert) {
			 * Found Command: let temp = dx; 
			 * Found Command: let dx = dy;
			 * Found Command: let dy = temp;
			 * Found Command: let positivex = (y < desty);
			 * Found Command: let positivey = (x < destx);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: let positivex = (x < destx);
			 * Found Command: let positivey = (y < desty);
			 * Found Command: }
			 * Found Command: let d = (2 * dy) - dx;
			 * Found Command: let straightD = 2 * dy;
			 * Found Command: let diagonalD = 2 * (dy - dx);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method int move() {
			 * Found Command: do hide();
			 * Found Command: if (d < 0) { let d = d + straightD; }
			 * Found Command: else {
			 * Found Command: let d = d + diagonalD;
			 * Found Command: if (positivey) {
			 * Found Command: if (invert) { let x = x + 4; }
			 * Found Command: else { let y = y + 4; }
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (invert) { let x = x - 4; }
			 * Found Command: else { let y = y - 4; }
			 * Found Command: }
			 * Found Command: }
			 * Found Command: if (positivex) {
			 * Found Command: if (invert) { let y = y + 4; }
			 * Found Command: else { let x = x + 4; }
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (invert) { let y = y - 4; }
			 * Found Command: else { let x = x - 4; }
			 * Found Command: }
			 * Found Command: if (~(x > leftWall)) {
			 * Found Command: let wall = 1;    
			 * Found Command: let x = leftWall;
			 * Found Command: }
			 * Found Command: if (~(x < rightWall)) {
			 * Found Command: let wall = 2;    
			 * Found Command: let x = rightWall;
			 * Found Command: }
			 * Found Command: if (~(y > topWall)) {
			 * Found Command: let wall = 3;    
			 * Found Command: let y = topWall;
			 * Found Command: }
			 * Found Command: if (~(y < bottomWall)) {
			 * Found Command: let wall = 4;    
			 * Found Command: let y = bottomWall;
			 * Found Command: }
			 * Found Command: do show();
			 * Found Command: return wall;
			 * Found Command: }
			 * Found Command: method void bounce(int bouncingDirection) {
			 * Found Command: var int newx, newy, divLengthx, divLengthy, factor;
			 * Found Command: 
			 * Found Command: let divLengthx = lengthx / 10;
			 * Found Command: let divLengthy = lengthy / 10;
			 * Found Command: if (bouncingDirection = 0) { let factor = 10; }
			 * Found Command: else {
			 * Found Command: if (((~(lengthx < 0)) & (bouncingDirection = 1)) | ((lengthx < 0) & (bouncingDirection = (-1)))) {
			 * Found Command: let factor = 20; 
			 * Found Command: }
			 * Found Command: else { let factor = 5; } 
			 * Found Command: }
			 * Found Command: if (wall = 1) {
			 * Found Command: let newx = 506;
			 * Found Command: let newy = (divLengthy * (-50)) / divLengthx;
			 * Found Command: let newy = y + (newy * factor);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (wall = 2) {
			 * Found Command: let newx = 0;
			 * Found Command: let newy = (divLengthy * 50) / divLengthx;
			 * Found Command: let newy = y + (newy * factor);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: if (wall = 3) {
			 * Found Command: let newy = 250;
			 * Found Command: let newx = (divLengthx * (-25)) / divLengthy;
			 * Found Command: let newx = x + (newx * factor);
			 * Found Command: }
			 * Found Command: else { 
			 * Found Command: let newy = 0;
			 * Found Command: let newx = (divLengthx * 25) / divLengthy;
			 * Found Command: let newx = x + (newx * factor);
			 * Found Command: }
			 * Found Command: }
			 * Found Command: }
			 * Found Command: do setDestination(newx, newy);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: straightD	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: diagonalD	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: boolean	     TYPE: keyword
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: constructor	     TYPE: keyword
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: AleftWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: ArightWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: AtopWall	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: AbottomWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: AleftWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ArightWall	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 6	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: AtopWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: AbottomWall	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 6	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Memory	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: deAlloc	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: setDestination	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: temp	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Math	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: abs	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Math	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: abs	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: temp	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: temp	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: destx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: desty	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: straightD	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: diagonalD	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: dy	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: dx	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: straightD	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: d	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: diagonalD	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: positivey	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: positivex	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: invert	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: leftWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: rightWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: topWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: bottomWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: bounce	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: lengthy	     TYPE: identifier
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: |	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: lengthx	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 20	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 5	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 506	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 250	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 25	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: divLengthx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: 25	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: /	     TYPE: symbol
			* Inserting Token -- NAME: divLengthy	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: *	     TYPE: symbol
			* Inserting Token -- NAME: factor	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: setDestination	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: newx	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: newy	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Analyzing
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Var Declaration
			* Done Analyzing Var Declaration
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Var Declaration
			* Done Analyzing Var Declaration
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
		* Done Analyzing
* Freeing all data used
	* Compiling File: Pong//Bat.jack
	* Tokenizer output file: Pong//BatT.xml
	* Analyzer output file: Pong//Bat.xml
	 * Beginning parsing
			 * Found Command: class Bat {
			 * Found Command: field int x, y;           
			 * Found Command: field int width, height;  
			 * Found Command: field int direction;      
			 * Found Command: constructor Bat new(int Ax, int Ay, int Awidth, int Aheight) {
			 * Found Command: let x = Ax;
			 * Found Command: let y = Ay;
			 * Found Command: let width = Awidth;
			 * Found Command: let height = Aheight;
			 * Found Command: let direction = 2;
			 * Found Command: do show();
			 * Found Command: return this;
			 * Found Command: }
			 * Found Command: method void dispose() {
			 * Found Command: do Memory.deAlloc(this);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void show() {
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void hide() {
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do draw();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void draw() {
			 * Found Command: do Screen.drawRectangle(x, y, x + width, y + height);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void setDirection(int Adirection) {
			 * Found Command: let direction = Adirection;
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method int getLeft() {
			 * Found Command: return x;
			 * Found Command: }
			 * Found Command: method int getRight() {
			 * Found Command: return x + width;
			 * Found Command: }
			 * Found Command: method void setWidth(int Awidth) {
			 * Found Command: do hide();
			 * Found Command: let width = Awidth;
			 * Found Command: do show();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void move() {
			 * Found Command: if (direction = 1) {
			 * Found Command: let x = x - 4;
			 * Found Command: if (x < 0) { let x = 0; }
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do Screen.drawRectangle((x + width) + 1, y, (x + width) + 4, y + height);
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do Screen.drawRectangle(x, y, x + 3, y + height);
			 * Found Command: }
			 * Found Command: else {
			 * Found Command: let x = x + 4;
			 * Found Command: if ((x + width) > 511) { let x = 511 - width; }
			 * Found Command: do Screen.setColor(false);
			 * Found Command: do Screen.drawRectangle(x - 4, y, x - 1, y + height);
			 * Found Command: do Screen.setColor(true);
			 * Found Command: do Screen.drawRectangle((x + width) - 3, y, x + width, y + height);
			 * Found Command: }
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: constructor	     TYPE: keyword
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Aheight	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ax	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ay	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Aheight	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Memory	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: deAlloc	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: draw	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: setDirection	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Adirection	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Adirection	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: setWidth	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: hide	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Awidth	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: show	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: direction	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setColor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 3	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: x	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: width	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: y	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: height	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Analyzing
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
		* Done Analyzing
* Freeing all data used
	* Compiling File: Pong//PongGame.jack
	* Tokenizer output file: Pong//PongGameT.xml
	* Analyzer output file: Pong//PongGame.xml
	 * Beginning parsing
			 * Found Command: class PongGame {
			 * Found Command: static PongGame instance; 
			 * Found Command: field Bat bat;            
			 * Found Command: field Ball ball;          
			 * Found Command: field int wall;           
			 * Found Command: field boolean exit;       
			 * Found Command: field int score;          
			 * Found Command: field int lastWall;       
			 * Found Command: 
			 * Found Command: field int batWidth;
			 * Found Command: constructor PongGame new() {
			 * Found Command: do Screen.clearScreen();
			 * Found Command: let batWidth = 50;  
			 * Found Command: let bat = Bat.new(230, 229, batWidth, 7);
			 * Found Command: let ball = Ball.new(253, 222, 0, 511, 0, 229);
			 * Found Command: do ball.setDestination(400,0);
			 * Found Command: do Screen.drawRectangle(0, 238, 511, 240);
			 * Found Command: do Output.moveCursor(22,0);
			 * Found Command: do Output.printString("Score: 0");
			 * Found Command: 
			 * Found Command: let exit = false;
			 * Found Command: let score = 0;
			 * Found Command: let wall = 0;
			 * Found Command: let lastWall = 0;
			 * Found Command: return this;
			 * Found Command: }
			 * Found Command: method void dispose() {
			 * Found Command: do bat.dispose();
			 * Found Command: do ball.dispose();
			 * Found Command: do Memory.deAlloc(this);
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: function void newInstance() {
			 * Found Command: let instance = PongGame.new();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: 
			 * Found Command: function PongGame getInstance() {
			 * Found Command: return instance;
			 * Found Command: }
			 * Found Command: method void run() {
			 * Found Command: var char key;
			 * Found Command: while (~exit) {
			 * Found Command: 
			 * Found Command: while ((key = 0) & (~exit)) {
			 * Found Command: let key = Keyboard.keyPressed();
			 * Found Command: do bat.move();
			 * Found Command: do moveBall();
			 * Found Command: do Sys.wait(50);
			 * Found Command: }
			 * Found Command: if (key = 130) { do bat.setDirection(1); }
			 * Found Command: else {
			 * Found Command: if (key = 132) { do bat.setDirection(2); }
			 * Found Command: else {
			 * Found Command: if (key = 140) { let exit = true; }
			 * Found Command: }
			 * Found Command: }
			 * Found Command: 
			 * Found Command: while ((~(key = 0)) & (~exit)) {
			 * Found Command: let key = Keyboard.keyPressed();
			 * Found Command: do bat.move();
			 * Found Command: do moveBall();
			 * Found Command: do Sys.wait(50);
			 * Found Command: }
			 * Found Command: }
			 * Found Command: if (exit) {
			 * Found Command: do Output.moveCursor(10,27);
			 * Found Command: do Output.printString("Game Over");
			 * Found Command: }
			 * Found Command: 
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: method void moveBall() {
			 * Found Command: var int bouncingDirection, batLeft, batRight, ballLeft, ballRight;
			 * Found Command: let wall = ball.move();
			 * Found Command: if ((wall > 0) & (~(wall = lastWall))) {
			 * Found Command: let lastWall = wall;
			 * Found Command: let bouncingDirection = 0;
			 * Found Command: let batLeft = bat.getLeft();
			 * Found Command: let batRight = bat.getRight();
			 * Found Command: let ballLeft = ball.getLeft();
			 * Found Command: let ballRight = ball.getRight();
			 * Found Command: 
			 * Found Command: if (wall = 4) {
			 * Found Command: let exit = (batLeft > ballRight) | (batRight < ballLeft);
			 * Found Command: if (~exit) {
			 * Found Command: if (ballRight < (batLeft + 10)) { let bouncingDirection = -1; }
			 * Found Command: else {
			 * Found Command: if (ballLeft > (batRight - 10)) { let bouncingDirection = 1; }
			 * Found Command: }
			 * Found Command: let batWidth = batWidth - 2;
			 * Found Command: do bat.setWidth(batWidth);      
			 * Found Command: let score = score + 1;
			 * Found Command: do Output.moveCursor(22,7);
			 * Found Command: do Output.printInt(score);
			 * Found Command: }
			 * Found Command: }
			 * Found Command: do ball.bounce(bouncingDirection);
			 * Found Command: }
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: static	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: instance	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: boolean	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: field	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: constructor	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: clearScreen	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 230	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 229	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 7	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 253	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 222	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 229	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setDestination	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 400	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Screen	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: drawRectangle	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 238	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 511	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 240	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: moveCursor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 22	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: printString	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: Score: 0	     TYPE: stringConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: false	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Memory	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: deAlloc	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: this	     TYPE: keyword
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: function	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: newInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: instance	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: new	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: function	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: getInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: instance	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: run	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: char	     TYPE: keyword
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: while	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: while	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Keyboard	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: keyPressed	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: moveBall	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Sys	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: wait	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 130	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setDirection	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 132	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setDirection	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 140	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: true	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: while	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: key	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: Keyboard	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: keyPressed	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: moveBall	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Sys	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: wait	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 50	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: moveCursor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 27	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: printString	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: Game Over	     TYPE: stringConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: method	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: moveBall	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: int	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: move	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: &amp;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: lastWall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 0	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getLeft	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getRight	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: wall	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 4	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: |	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ~	     TYPE: symbol
			* Inserting Token -- NAME: exit	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ballRight	     TYPE: identifier
			* Inserting Token -- NAME: &lt;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batLeft	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: else	     TYPE: keyword
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: if	     TYPE: keyword
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: ballLeft	     TYPE: identifier
			* Inserting Token -- NAME: &gt;	     TYPE: symbol
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batRight	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 10	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: -	     TYPE: symbol
			* Inserting Token -- NAME: 2	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: bat	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: setWidth	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: batWidth	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: +	     TYPE: symbol
			* Inserting Token -- NAME: 1	     TYPE: integerConstant
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: moveCursor	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: 22	     TYPE: integerConstant
			* Inserting Token -- NAME: ,	     TYPE: symbol
			* Inserting Token -- NAME: 7	     TYPE: integerConstant
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: Output	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: printInt	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: score	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: ball	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: bounce	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: bouncingDirection	     TYPE: identifier
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Analyzing
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Class Var Declaration
			* Done Analyzing Class Var Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Statements
			* Analyzing Return Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Var Declaration
			* Done Analyzing Var Declaration
			* Analyzing Statements
			* Analyzing While Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing While Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Done Analyzing While Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing While Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Done Analyzing While Statement
			* Done Analyzing Statements
			* Done Analyzing While Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Var Declaration
			* Done Analyzing Var Declaration
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Analyzing Statements
			* Analyzing If Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Statements
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Analyzing Expression
			* Analyzing Terminal
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Done Analyzing Statements
			* Done Analyzing If Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
		* Done Analyzing
* Freeing all data used
	* Compiling File: Pong//Main.jack
	* Tokenizer output file: Pong//MainT.xml
	* Analyzer output file: Pong//Main.xml
	 * Beginning parsing
			 * Found Command: class Main {
			 * Found Command: function void main() {
			 * Found Command: var PongGame game;
			 * Found Command: do PongGame.newInstance();
			 * Found Command: let game = PongGame.getInstance();
			 * Found Command: do game.run();
			 * Found Command: do game.dispose();
			 * Found Command: return;
			 * Found Command: }
			 * Found Command: }
	 * Done parsing
		* Beginning Tokenizing
			* Inserting Token -- NAME: class	     TYPE: keyword
			* Inserting Token -- NAME: Main	     TYPE: identifier
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: function	     TYPE: keyword
			* Inserting Token -- NAME: void	     TYPE: keyword
			* Inserting Token -- NAME: main	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: {	     TYPE: symbol
			* Inserting Token -- NAME: var	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: newInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: let	     TYPE: keyword
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: =	     TYPE: symbol
			* Inserting Token -- NAME: PongGame	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: getInstance	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: run	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: do	     TYPE: keyword
			* Inserting Token -- NAME: game	     TYPE: identifier
			* Inserting Token -- NAME: .	     TYPE: symbol
			* Inserting Token -- NAME: dispose	     TYPE: identifier
			* Inserting Token -- NAME: (	     TYPE: symbol
			* Inserting Token -- NAME: )	     TYPE: symbol
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: return	     TYPE: keyword
			* Inserting Token -- NAME: ;	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
			* Inserting Token -- NAME: }	     TYPE: symbol
		* Done Tokenizing
		* Beginning Analyzing
			* Analyzing Subroutine Declaration
			* Analyzing Parameter List
			* Done Analyzing Parameter List
			* Analyzing Subroutine Body
			* Analyzing Var Declaration
			* Done Analyzing Var Declaration
			* Analyzing Statements
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Let Statement
			* Analyzing Expression
			* Analyzing Terminal
			* Analyzing Subroutine Call
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Subroutine Call
			* Done Analyzing Terminal
			* Done Analyzing Expression
			* Done Analyzing Let Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Do Statement
			* Analyzing Expression List
			* Done Analyzing Expression List
			* Done Analyzing Do Statement
			* Analyzing Return Statement
			* Done Analyzing Return Statement
			* Done Analyzing Statements
			* Done Analyzing Subroutine Body
			* Done Analyzing Subroutine Declaration
		* Done Analyzing
* Freeing all data used
* Found instruction: function Main.main 1
	* In doFunc
		* Setting currFunc: main
* Found instruction: call PongGame.newInstance 0
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnMain.main0)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: call PongGame.getInstance 0
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnMain.main1)
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: call PongGame.run 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnMain.main2)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: call PongGame.dispose 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnMain.main3)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.new 0
	* In doFunc
		* Setting currFunc: Main.main
* Found instruction: push constant 5
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 5
* Found instruction: call Memory.alloc 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.new4)
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: push argument 2
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 2
* Found instruction: pop this 2
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 2
* Found instruction: push argument 3
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 3
* Found instruction: pop this 3
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 3
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Bat.show 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.new5)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.dispose 0
	* In doFunc
		* Setting currFunc: Bat.new
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Memory.deAlloc 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.dispose6)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.show 0
	* In doFunc
		* Setting currFunc: Bat.dispose
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.show7)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Bat.draw 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.show8)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.hide 0
	* In doFunc
		* Setting currFunc: Bat.show
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.hide9)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Bat.draw 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.hide10)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.draw 0
	* In doFunc
		* Setting currFunc: Bat.hide
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.draw11)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.setDirection 0
	* In doFunc
		* Setting currFunc: Bat.draw
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.getLeft 0
	* In doFunc
		* Setting currFunc: Bat.setDirection
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.getRight 0
	* In doFunc
		* Setting currFunc: Bat.getLeft
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.setWidth 0
	* In doFunc
		* Setting currFunc: Bat.getRight
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Bat.hide 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.setWidth12)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: pop this 2
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 2
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Bat.show 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.setWidth13)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Bat.move 0
	* In doFunc
		* Setting currFunc: Bat.setWidth
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 4
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 4
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE51
	* In doIfGoto
		* Setting label: IF-TRUE51
* Found instruction: goto IF-FALSE52
	* In doGoto
		* Setting label: IF-FALSE52
* Found instruction: label IF-TRUE51
	* In doLabel
		* Setting label: IF-TRUE51
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE54
	* In doIfGoto
		* Setting label: IF-TRUE54
* Found instruction: goto IF-FALSE55
	* In doGoto
		* Setting label: IF-FALSE55
* Found instruction: label IF-TRUE54
	* In doLabel
		* Setting label: IF-TRUE54
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: goto IF-END56
	* In doGoto
		* Setting label: IF-END56
* Found instruction: label IF-FALSE55
	* In doLabel
		* Setting label: IF-FALSE55
* Found instruction: label IF-END56
	* In doLabel
		* Setting label: IF-END56
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move14)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move15)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move16)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 3
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 3
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move17)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto IF-END53
	* In doGoto
		* Setting label: IF-END53
* Found instruction: label IF-FALSE52
	* In doLabel
		* Setting label: IF-FALSE52
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push constant 511
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 511
* Found instruction: gt
	* In doArithmetic
		* Action: gt
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE57
	* In doIfGoto
		* Setting label: IF-TRUE57
* Found instruction: goto IF-FALSE58
	* In doGoto
		* Setting label: IF-FALSE58
* Found instruction: label IF-TRUE57
	* In doLabel
		* Setting label: IF-TRUE57
* Found instruction: push constant 511
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 511
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: goto IF-END59
	* In doGoto
		* Setting label: IF-END59
* Found instruction: label IF-FALSE58
	* In doLabel
		* Setting label: IF-FALSE58
* Found instruction: label IF-END59
	* In doLabel
		* Setting label: IF-END59
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move18)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move19)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move20)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push constant 3
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 3
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBat.move21)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: label IF-END53
	* In doLabel
		* Setting label: IF-END53
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.new 0
	* In doFunc
		* Setting currFunc: Bat.move
* Found instruction: push constant 15
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 15
* Found instruction: call Memory.alloc 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.new22)
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: push argument 2
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 2
* Found instruction: pop this 10
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 10
* Found instruction: push argument 3
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 3
* Found instruction: push constant 6
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 6
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 11
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 11
* Found instruction: push argument 4
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 4
* Found instruction: pop this 12
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 12
* Found instruction: push argument 5
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 5
* Found instruction: push constant 6
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 6
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 13
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 13
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop this 14
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 14
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Ball.show 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.new23)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.dispose 0
	* In doFunc
		* Setting currFunc: Ball.new
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Memory.deAlloc 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.dispose24)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.show 0
	* In doFunc
		* Setting currFunc: Ball.dispose
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.show25)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Ball.draw 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.show26)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.hide 0
	* In doFunc
		* Setting currFunc: Ball.show
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: call Screen.setColor 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.hide27)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Ball.draw 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.hide28)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.draw 0
	* In doFunc
		* Setting currFunc: Ball.hide
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 5
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 5
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push constant 5
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 5
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.draw29)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.getLeft 0
	* In doFunc
		* Setting currFunc: Ball.draw
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.getRight 0
	* In doFunc
		* Setting currFunc: Ball.getLeft
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 5
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 5
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.setDestination 3
	* In doFunc
		* Setting currFunc: Ball.getRight
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 2
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 2
* Found instruction: push argument 2
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 2
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 3
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 3
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: call Math.abs 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.setDestination30)
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: call Math.abs 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.setDestination31)
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 7
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 7
* Found instruction: push this 7
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 7
* Found instruction: if-goto IF-TRUE0
	* In doIfGoto
		* Setting label: IF-TRUE0
* Found instruction: goto IF-FALSE1
	* In doGoto
		* Setting label: IF-FALSE1
* Found instruction: label IF-TRUE0
	* In doLabel
		* Setting label: IF-TRUE0
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: pop local 2
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 2
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push argument 2
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 2
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 8
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 8
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 9
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 9
* Found instruction: goto IF-END2
	* In doGoto
		* Setting label: IF-END2
* Found instruction: label IF-FALSE1
	* In doLabel
		* Setting label: IF-FALSE1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 8
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 8
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push argument 2
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 2
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 9
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 9
* Found instruction: label IF-END2
	* In doLabel
		* Setting label: IF-END2
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.setDestination32)
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.setDestination33)
* Found instruction: pop this 5
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 5
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.setDestination34)
* Found instruction: pop this 6
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 6
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.move 0
	* In doFunc
		* Setting currFunc: Ball.setDestination
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Ball.hide 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.move35)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 4
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 4
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE3
	* In doIfGoto
		* Setting label: IF-TRUE3
* Found instruction: goto IF-FALSE4
	* In doGoto
		* Setting label: IF-FALSE4
* Found instruction: label IF-TRUE3
	* In doLabel
		* Setting label: IF-TRUE3
* Found instruction: push this 4
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 4
* Found instruction: push this 5
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 5
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: goto IF-END5
	* In doGoto
		* Setting label: IF-END5
* Found instruction: label IF-FALSE4
	* In doLabel
		* Setting label: IF-FALSE4
* Found instruction: push this 4
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 4
* Found instruction: push this 6
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 6
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: push this 9
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 9
* Found instruction: if-goto IF-TRUE6
	* In doIfGoto
		* Setting label: IF-TRUE6
* Found instruction: goto IF-FALSE7
	* In doGoto
		* Setting label: IF-FALSE7
* Found instruction: label IF-TRUE6
	* In doLabel
		* Setting label: IF-TRUE6
* Found instruction: push this 7
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 7
* Found instruction: if-goto IF-TRUE9
	* In doIfGoto
		* Setting label: IF-TRUE9
* Found instruction: goto IF-FALSE10
	* In doGoto
		* Setting label: IF-FALSE10
* Found instruction: label IF-TRUE9
	* In doLabel
		* Setting label: IF-TRUE9
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: goto IF-END11
	* In doGoto
		* Setting label: IF-END11
* Found instruction: label IF-FALSE10
	* In doLabel
		* Setting label: IF-FALSE10
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: label IF-END11
	* In doLabel
		* Setting label: IF-END11
* Found instruction: goto IF-END8
	* In doGoto
		* Setting label: IF-END8
* Found instruction: label IF-FALSE7
	* In doLabel
		* Setting label: IF-FALSE7
* Found instruction: push this 7
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 7
* Found instruction: if-goto IF-TRUE12
	* In doIfGoto
		* Setting label: IF-TRUE12
* Found instruction: goto IF-FALSE13
	* In doGoto
		* Setting label: IF-FALSE13
* Found instruction: label IF-TRUE12
	* In doLabel
		* Setting label: IF-TRUE12
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: goto IF-END14
	* In doGoto
		* Setting label: IF-END14
* Found instruction: label IF-FALSE13
	* In doLabel
		* Setting label: IF-FALSE13
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: label IF-END14
	* In doLabel
		* Setting label: IF-END14
* Found instruction: label IF-END8
	* In doLabel
		* Setting label: IF-END8
* Found instruction: label IF-END5
	* In doLabel
		* Setting label: IF-END5
* Found instruction: push this 8
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 8
* Found instruction: if-goto IF-TRUE15
	* In doIfGoto
		* Setting label: IF-TRUE15
* Found instruction: goto IF-FALSE16
	* In doGoto
		* Setting label: IF-FALSE16
* Found instruction: label IF-TRUE15
	* In doLabel
		* Setting label: IF-TRUE15
* Found instruction: push this 7
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 7
* Found instruction: if-goto IF-TRUE18
	* In doIfGoto
		* Setting label: IF-TRUE18
* Found instruction: goto IF-FALSE19
	* In doGoto
		* Setting label: IF-FALSE19
* Found instruction: label IF-TRUE18
	* In doLabel
		* Setting label: IF-TRUE18
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: goto IF-END20
	* In doGoto
		* Setting label: IF-END20
* Found instruction: label IF-FALSE19
	* In doLabel
		* Setting label: IF-FALSE19
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: label IF-END20
	* In doLabel
		* Setting label: IF-END20
* Found instruction: goto IF-END17
	* In doGoto
		* Setting label: IF-END17
* Found instruction: label IF-FALSE16
	* In doLabel
		* Setting label: IF-FALSE16
* Found instruction: push this 7
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 7
* Found instruction: if-goto IF-TRUE21
	* In doIfGoto
		* Setting label: IF-TRUE21
* Found instruction: goto IF-FALSE22
	* In doGoto
		* Setting label: IF-FALSE22
* Found instruction: label IF-TRUE21
	* In doLabel
		* Setting label: IF-TRUE21
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: goto IF-END23
	* In doGoto
		* Setting label: IF-END23
* Found instruction: label IF-FALSE22
	* In doLabel
		* Setting label: IF-FALSE22
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: label IF-END23
	* In doLabel
		* Setting label: IF-END23
* Found instruction: label IF-END17
	* In doLabel
		* Setting label: IF-END17
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 10
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 10
* Found instruction: gt
	* In doArithmetic
		* Action: gt
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE24
	* In doIfGoto
		* Setting label: IF-TRUE24
* Found instruction: goto IF-FALSE25
	* In doGoto
		* Setting label: IF-FALSE25
* Found instruction: label IF-TRUE24
	* In doLabel
		* Setting label: IF-TRUE24
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: pop this 14
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 14
* Found instruction: push this 10
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 10
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: goto IF-END26
	* In doGoto
		* Setting label: IF-END26
* Found instruction: label IF-FALSE25
	* In doLabel
		* Setting label: IF-FALSE25
* Found instruction: label IF-END26
	* In doLabel
		* Setting label: IF-END26
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 11
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 11
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE27
	* In doIfGoto
		* Setting label: IF-TRUE27
* Found instruction: goto IF-FALSE28
	* In doGoto
		* Setting label: IF-FALSE28
* Found instruction: label IF-TRUE27
	* In doLabel
		* Setting label: IF-TRUE27
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: pop this 14
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 14
* Found instruction: push this 11
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 11
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: goto IF-END29
	* In doGoto
		* Setting label: IF-END29
* Found instruction: label IF-FALSE28
	* In doLabel
		* Setting label: IF-FALSE28
* Found instruction: label IF-END29
	* In doLabel
		* Setting label: IF-END29
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 12
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 12
* Found instruction: gt
	* In doArithmetic
		* Action: gt
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE30
	* In doIfGoto
		* Setting label: IF-TRUE30
* Found instruction: goto IF-FALSE31
	* In doGoto
		* Setting label: IF-FALSE31
* Found instruction: label IF-TRUE30
	* In doLabel
		* Setting label: IF-TRUE30
* Found instruction: push constant 3
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 3
* Found instruction: pop this 14
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 14
* Found instruction: push this 12
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 12
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: goto IF-END32
	* In doGoto
		* Setting label: IF-END32
* Found instruction: label IF-FALSE31
	* In doLabel
		* Setting label: IF-FALSE31
* Found instruction: label IF-END32
	* In doLabel
		* Setting label: IF-END32
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push this 13
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 13
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE33
	* In doIfGoto
		* Setting label: IF-TRUE33
* Found instruction: goto IF-FALSE34
	* In doGoto
		* Setting label: IF-FALSE34
* Found instruction: label IF-TRUE33
	* In doLabel
		* Setting label: IF-TRUE33
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: pop this 14
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 14
* Found instruction: push this 13
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 13
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: goto IF-END35
	* In doGoto
		* Setting label: IF-END35
* Found instruction: label IF-FALSE34
	* In doLabel
		* Setting label: IF-FALSE34
* Found instruction: label IF-END35
	* In doLabel
		* Setting label: IF-END35
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Ball.show 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.move36)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 14
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 14
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function Ball.bounce 5
	* In doFunc
		* Setting currFunc: Ball.move
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: push constant 10
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 10
* Found instruction: call Math.divide 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce37)
* Found instruction: pop local 2
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 2
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: push constant 10
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 10
* Found instruction: call Math.divide 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce38)
* Found instruction: pop local 3
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 3
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE36
	* In doIfGoto
		* Setting label: IF-TRUE36
* Found instruction: goto IF-FALSE37
	* In doGoto
		* Setting label: IF-FALSE37
* Found instruction: label IF-TRUE36
	* In doLabel
		* Setting label: IF-TRUE36
* Found instruction: push constant 10
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 10
* Found instruction: pop local 4
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 4
* Found instruction: goto IF-END38
	* In doGoto
		* Setting label: IF-END38
* Found instruction: label IF-FALSE37
	* In doLabel
		* Setting label: IF-FALSE37
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: and
	* In doArithmetic
		* Action: and
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: push argument 1
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 1
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: neg
	* In doArithmetic
		* Action: neg
		* Segment: NULL
		* Offset: NULL
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: and
	* In doArithmetic
		* Action: and
		* Segment: NULL
		* Offset: NULL
* Found instruction: or
	* In doArithmetic
		* Action: or
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE39
	* In doIfGoto
		* Setting label: IF-TRUE39
* Found instruction: goto IF-FALSE40
	* In doGoto
		* Setting label: IF-FALSE40
* Found instruction: label IF-TRUE39
	* In doLabel
		* Setting label: IF-TRUE39
* Found instruction: push constant 20
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 20
* Found instruction: pop local 4
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 4
* Found instruction: goto IF-END41
	* In doGoto
		* Setting label: IF-END41
* Found instruction: label IF-FALSE40
	* In doLabel
		* Setting label: IF-FALSE40
* Found instruction: push constant 5
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 5
* Found instruction: pop local 4
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 4
* Found instruction: label IF-END41
	* In doLabel
		* Setting label: IF-END41
* Found instruction: label IF-END38
	* In doLabel
		* Setting label: IF-END38
* Found instruction: push this 14
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 14
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE42
	* In doIfGoto
		* Setting label: IF-TRUE42
* Found instruction: goto IF-FALSE43
	* In doGoto
		* Setting label: IF-FALSE43
* Found instruction: label IF-TRUE42
	* In doLabel
		* Setting label: IF-TRUE42
* Found instruction: push constant 506
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 506
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push local 3
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 3
* Found instruction: push constant 50
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 50
* Found instruction: neg
	* In doArithmetic
		* Action: neg
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce39)
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: call Math.divide 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce40)
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: push local 4
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 4
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce41)
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: goto IF-END44
	* In doGoto
		* Setting label: IF-END44
* Found instruction: label IF-FALSE43
	* In doLabel
		* Setting label: IF-FALSE43
* Found instruction: push this 14
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 14
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE45
	* In doIfGoto
		* Setting label: IF-TRUE45
* Found instruction: goto IF-FALSE46
	* In doGoto
		* Setting label: IF-FALSE46
* Found instruction: label IF-TRUE45
	* In doLabel
		* Setting label: IF-TRUE45
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push local 3
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 3
* Found instruction: push constant 50
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 50
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce42)
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: call Math.divide 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce43)
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: push local 4
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 4
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce44)
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: goto IF-END47
	* In doGoto
		* Setting label: IF-END47
* Found instruction: label IF-FALSE46
	* In doLabel
		* Setting label: IF-FALSE46
* Found instruction: push this 14
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 14
* Found instruction: push constant 3
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 3
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE48
	* In doIfGoto
		* Setting label: IF-TRUE48
* Found instruction: goto IF-FALSE49
	* In doGoto
		* Setting label: IF-FALSE49
* Found instruction: label IF-TRUE48
	* In doLabel
		* Setting label: IF-TRUE48
* Found instruction: push constant 250
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 250
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: push constant 25
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 25
* Found instruction: neg
	* In doArithmetic
		* Action: neg
		* Segment: NULL
		* Offset: NULL
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce45)
* Found instruction: push local 3
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 3
* Found instruction: call Math.divide 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce46)
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push local 4
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 4
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce47)
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: goto IF-END50
	* In doGoto
		* Setting label: IF-END50
* Found instruction: label IF-FALSE49
	* In doLabel
		* Setting label: IF-FALSE49
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: push constant 25
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 25
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce48)
* Found instruction: push local 3
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 3
* Found instruction: call Math.divide 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce49)
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push local 4
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 4
* Found instruction: call Math.multiply 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce50)
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: label IF-END50
	* In doLabel
		* Setting label: IF-END50
* Found instruction: label IF-END47
	* In doLabel
		* Setting label: IF-END47
* Found instruction: label IF-END44
	* In doLabel
		* Setting label: IF-END44
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: call Ball.setDestination 3
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnBall.bounce51)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function PongGame.new 0
	* In doFunc
		* Setting currFunc: Ball.bounce
* Found instruction: push constant 7
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 7
* Found instruction: call Memory.alloc 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new52)
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: call Screen.clearScreen 0
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new53)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 50
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 50
* Found instruction: pop this 6
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 6
* Found instruction: push constant 230
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 230
* Found instruction: push constant 229
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 229
* Found instruction: push this 6
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 6
* Found instruction: push constant 7
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 7
* Found instruction: call Bat.new 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new54)
* Found instruction: pop this 0
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 0
* Found instruction: push constant 253
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 253
* Found instruction: push constant 222
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 222
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: push constant 511
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 511
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: push constant 229
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 229
* Found instruction: call Ball.new 6
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new55)
* Found instruction: pop this 1
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 1
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push constant 400
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 400
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: call Ball.setDestination 3
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new56)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: push constant 238
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 238
* Found instruction: push constant 511
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 511
* Found instruction: push constant 240
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 240
* Found instruction: call Screen.drawRectangle 4
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new57)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 22
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 22
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: call Output.moveCursor 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new58)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 8
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 8
* Found instruction: call String.new 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new59)
* Found instruction: push constant 83
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 83
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new60)
* Found instruction: push constant 99
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 99
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new61)
* Found instruction: push constant 111
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 111
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new62)
* Found instruction: push constant 114
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 114
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new63)
* Found instruction: push constant 101
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 101
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new64)
* Found instruction: push constant 58
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 58
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new65)
* Found instruction: push constant 32
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 32
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new66)
* Found instruction: push constant 48
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 48
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new67)
* Found instruction: call Output.printString 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.new68)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop this 3
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 3
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop this 2
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 2
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop this 5
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 5
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function PongGame.dispose 0
	* In doFunc
		* Setting currFunc: PongGame.new
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: call Bat.dispose 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.dispose69)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: call Ball.dispose 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.dispose70)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call Memory.deAlloc 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.dispose71)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function PongGame.newInstance 0
	* In doFunc
		* Setting currFunc: PongGame.dispose
* Found instruction: call PongGame.new 0
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.newInstance72)
* Found instruction: pop static 0
	* In doPop
		* Action: pop
		* Segment: static
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function PongGame.getInstance 0
	* In doFunc
		* Setting currFunc: PongGame.newInstance
* Found instruction: push static 0
	* In doPush
		* Action: push
		* Segment: static
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function PongGame.run 1
	* In doFunc
		* Setting currFunc: PongGame.getInstance
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: label W60
	* In doLabel
		* Setting label: W60
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto W61
	* In doIfGoto
		* Setting label: W61
* Found instruction: label W62
	* In doLabel
		* Setting label: W62
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: and
	* In doArithmetic
		* Action: and
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto W63
	* In doIfGoto
		* Setting label: W63
* Found instruction: call Keyboard.keyPressed 0
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run73)
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: call Bat.move 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run74)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call PongGame.moveBall 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run75)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 50
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 50
* Found instruction: call Sys.wait 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run76)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto W62
	* In doGoto
		* Setting label: W62
* Found instruction: label W63
	* In doLabel
		* Setting label: W63
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push constant 130
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 130
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE64
	* In doIfGoto
		* Setting label: IF-TRUE64
* Found instruction: goto IF-FALSE65
	* In doGoto
		* Setting label: IF-FALSE65
* Found instruction: label IF-TRUE64
	* In doLabel
		* Setting label: IF-TRUE64
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: call Bat.setDirection 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run77)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto IF-END66
	* In doGoto
		* Setting label: IF-END66
* Found instruction: label IF-FALSE65
	* In doLabel
		* Setting label: IF-FALSE65
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push constant 132
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 132
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE67
	* In doIfGoto
		* Setting label: IF-TRUE67
* Found instruction: goto IF-FALSE68
	* In doGoto
		* Setting label: IF-FALSE68
* Found instruction: label IF-TRUE67
	* In doLabel
		* Setting label: IF-TRUE67
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: call Bat.setDirection 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run78)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto IF-END69
	* In doGoto
		* Setting label: IF-END69
* Found instruction: label IF-FALSE68
	* In doLabel
		* Setting label: IF-FALSE68
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push constant 140
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 140
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE70
	* In doIfGoto
		* Setting label: IF-TRUE70
* Found instruction: goto IF-FALSE71
	* In doGoto
		* Setting label: IF-FALSE71
* Found instruction: label IF-TRUE70
	* In doLabel
		* Setting label: IF-TRUE70
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 3
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 3
* Found instruction: goto IF-END72
	* In doGoto
		* Setting label: IF-END72
* Found instruction: label IF-FALSE71
	* In doLabel
		* Setting label: IF-FALSE71
* Found instruction: label IF-END72
	* In doLabel
		* Setting label: IF-END72
* Found instruction: label IF-END69
	* In doLabel
		* Setting label: IF-END69
* Found instruction: label IF-END66
	* In doLabel
		* Setting label: IF-END66
* Found instruction: label W73
	* In doLabel
		* Setting label: W73
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: and
	* In doArithmetic
		* Action: and
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto W74
	* In doIfGoto
		* Setting label: W74
* Found instruction: call Keyboard.keyPressed 0
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run79)
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: call Bat.move 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run80)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push pointer 0
	* In doPush
		* Action: push
		* Segment: pointer
		* Offset: 0
* Found instruction: call PongGame.moveBall 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run81)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 50
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 50
* Found instruction: call Sys.wait 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run82)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto W73
	* In doGoto
		* Setting label: W73
* Found instruction: label W74
	* In doLabel
		* Setting label: W74
* Found instruction: goto W60
	* In doGoto
		* Setting label: W60
* Found instruction: label W61
	* In doLabel
		* Setting label: W61
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: if-goto IF-TRUE75
	* In doIfGoto
		* Setting label: IF-TRUE75
* Found instruction: goto IF-FALSE76
	* In doGoto
		* Setting label: IF-FALSE76
* Found instruction: label IF-TRUE75
	* In doLabel
		* Setting label: IF-TRUE75
* Found instruction: push constant 10
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 10
* Found instruction: push constant 27
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 27
* Found instruction: call Output.moveCursor 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run83)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push constant 9
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 9
* Found instruction: call String.new 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run84)
* Found instruction: push constant 71
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 71
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run85)
* Found instruction: push constant 97
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 97
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run86)
* Found instruction: push constant 109
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 109
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run87)
* Found instruction: push constant 101
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 101
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run88)
* Found instruction: push constant 32
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 32
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run89)
* Found instruction: push constant 79
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 79
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run90)
* Found instruction: push constant 118
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 118
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run91)
* Found instruction: push constant 101
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 101
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run92)
* Found instruction: push constant 114
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 114
* Found instruction: call String.appendChar 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run93)
* Found instruction: call Output.printString 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.run94)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto IF-END77
	* In doGoto
		* Setting label: IF-END77
* Found instruction: label IF-FALSE76
	* In doLabel
		* Setting label: IF-FALSE76
* Found instruction: label IF-END77
	* In doLabel
		* Setting label: IF-END77
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
* Found instruction: function PongGame.moveBall 5
	* In doFunc
		* Setting currFunc: PongGame.run
* Found instruction: push argument 0
	* In doPush
		* Action: push
		* Segment: argument
		* Offset: 0
* Found instruction: pop pointer 0
	* In doPop
		* Action: pop
		* Segment: pointer
		* Offset: 0
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: call Ball.move 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall95)
* Found instruction: pop this 2
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 2
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: gt
	* In doArithmetic
		* Action: gt
		* Segment: NULL
		* Offset: NULL
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: push this 5
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 5
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: and
	* In doArithmetic
		* Action: and
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE78
	* In doIfGoto
		* Setting label: IF-TRUE78
* Found instruction: goto IF-FALSE79
	* In doGoto
		* Setting label: IF-FALSE79
* Found instruction: label IF-TRUE78
	* In doLabel
		* Setting label: IF-TRUE78
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: pop this 5
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 5
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: call Bat.getLeft 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall96)
* Found instruction: pop local 1
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 1
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: call Bat.getRight 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall97)
* Found instruction: pop local 2
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 2
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: call Ball.getLeft 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall98)
* Found instruction: pop local 3
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 3
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: call Ball.getRight 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall99)
* Found instruction: pop local 4
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 4
* Found instruction: push this 2
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 2
* Found instruction: push constant 4
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 4
* Found instruction: eq
	* In doArithmetic
		* Action: eq
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE81
	* In doIfGoto
		* Setting label: IF-TRUE81
* Found instruction: goto IF-FALSE82
	* In doGoto
		* Setting label: IF-FALSE82
* Found instruction: label IF-TRUE81
	* In doLabel
		* Setting label: IF-TRUE81
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: push local 4
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 4
* Found instruction: gt
	* In doArithmetic
		* Action: gt
		* Segment: NULL
		* Offset: NULL
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: push local 3
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 3
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: or
	* In doArithmetic
		* Action: or
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 3
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 3
* Found instruction: push this 3
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 3
* Found instruction: not
	* In doArithmetic
		* Action: not
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE84
	* In doIfGoto
		* Setting label: IF-TRUE84
* Found instruction: goto IF-FALSE85
	* In doGoto
		* Setting label: IF-FALSE85
* Found instruction: label IF-TRUE84
	* In doLabel
		* Setting label: IF-TRUE84
* Found instruction: push local 4
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 4
* Found instruction: push local 1
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 1
* Found instruction: push constant 10
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 10
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: lt
	* In doArithmetic
		* Action: lt
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE87
	* In doIfGoto
		* Setting label: IF-TRUE87
* Found instruction: goto IF-FALSE88
	* In doGoto
		* Setting label: IF-FALSE88
* Found instruction: label IF-TRUE87
	* In doLabel
		* Setting label: IF-TRUE87
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: neg
	* In doArithmetic
		* Action: neg
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: goto IF-END89
	* In doGoto
		* Setting label: IF-END89
* Found instruction: label IF-FALSE88
	* In doLabel
		* Setting label: IF-FALSE88
* Found instruction: push local 3
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 3
* Found instruction: push local 2
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 2
* Found instruction: push constant 10
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 10
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: gt
	* In doArithmetic
		* Action: gt
		* Segment: NULL
		* Offset: NULL
* Found instruction: if-goto IF-TRUE90
	* In doIfGoto
		* Setting label: IF-TRUE90
* Found instruction: goto IF-FALSE91
	* In doGoto
		* Setting label: IF-FALSE91
* Found instruction: label IF-TRUE90
	* In doLabel
		* Setting label: IF-TRUE90
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: pop local 0
	* In doPop
		* Action: pop
		* Segment: local
		* Offset: 0
* Found instruction: goto IF-END92
	* In doGoto
		* Setting label: IF-END92
* Found instruction: label IF-FALSE91
	* In doLabel
		* Setting label: IF-FALSE91
* Found instruction: label IF-END92
	* In doLabel
		* Setting label: IF-END92
* Found instruction: label IF-END89
	* In doLabel
		* Setting label: IF-END89
* Found instruction: push this 6
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 6
* Found instruction: push constant 2
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 2
* Found instruction: sub
	* In doArithmetic
		* Action: sub
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 6
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 6
* Found instruction: push this 0
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 0
* Found instruction: push this 6
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 6
* Found instruction: call Bat.setWidth 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall100)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 4
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 4
* Found instruction: push constant 1
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 1
* Found instruction: add
	* In doArithmetic
		* Action: add
		* Segment: NULL
		* Offset: NULL
* Found instruction: pop this 4
	* In doPop
		* Action: pop
		* Segment: this
		* Offset: 4
* Found instruction: push constant 22
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 22
* Found instruction: push constant 7
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 7
* Found instruction: call Output.moveCursor 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall101)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: push this 4
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 4
* Found instruction: call Output.printInt 1
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall102)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto IF-END86
	* In doGoto
		* Setting label: IF-END86
* Found instruction: label IF-FALSE85
	* In doLabel
		* Setting label: IF-FALSE85
* Found instruction: label IF-END86
	* In doLabel
		* Setting label: IF-END86
* Found instruction: goto IF-END83
	* In doGoto
		* Setting label: IF-END83
* Found instruction: label IF-FALSE82
	* In doLabel
		* Setting label: IF-FALSE82
* Found instruction: label IF-END83
	* In doLabel
		* Setting label: IF-END83
* Found instruction: push this 1
	* In doPush
		* Action: push
		* Segment: this
		* Offset: 1
* Found instruction: push local 0
	* In doPush
		* Action: push
		* Segment: local
		* Offset: 0
* Found instruction: call Ball.bounce 2
	* In doCall
		* Pushing RA
		* Pushing LCL
		* Pushing ARG
		* Pushing THIS
		* Pushing THAT
		* Pushing ARG = SP - (nArgs + 5)
		* Pushing LCL = SP
		* GOTO function
		* Setting Call label: (returnPongGame.moveBall103)
* Found instruction: pop temp 0
	* In doPop
		* Action: pop
		* Segment: temp
		* Offset: 0
* Found instruction: goto IF-END80
	* In doGoto
		* Setting label: IF-END80
* Found instruction: label IF-FALSE79
	* In doLabel
		* Setting label: IF-FALSE79
* Found instruction: label IF-END80
	* In doLabel
		* Setting label: IF-END80
* Found instruction: push constant 0
	* In doPush
		* Action: push
		* Segment: constant
		* Offset: 0
* Found instruction: return
	* In doReturn
		* Setting FRAME = LCL
		* Setting RET = FRAME - 5
		* Popping ARG
		* Setting SP = ARG + 1
		* Popping THAT
		* Popping THIS
		* Popping ARG
		* Popping LCL
		* Writing GOTO return
	* Compiling File: Pong//Pong.asm
	* Assembler output file: Pong//Pong.hac
